# React

Create time: February 19, 2022 11:47 PM
Description: 用于构建用户界面的 JavaScript 库
Last edited time: July 5, 2022 11:07 AM
Logo: React%20068a8677f1874d7d8beabb6002f19b86/React.png
Official website: https://react.docschina.org/

[redux react-redux](https://www.notion.so/redux-react-redux-62bfa339daba48138b23b8500121c05d)

[react-router-dom](https://www.notion.so/react-router-dom-3148f91f87a345f6bf9b275d06a6c75f)

[react中webpack的配置](https://www.notion.so/react-webpack-fdfc98bf35ce45aea38c1deb844bd366)

[react与ts的融合使用](https://www.notion.so/react-ts-2340d62713b2413aa6c269ccd8fa79b6)

[react中css解决: css modules](https://www.notion.so/react-css-css-modules-48dd47faef804ee5b8a51bc95180074f)

[react项目打包优化](https://www.notion.so/react-20dc6bf2f8834b7d90000377d27d0b89)

[React项目中的问题](https://www.notion.so/React-9f97dd4b9a454c08926f0f1f0df1cc2a)

[react第三方库](https://www.notion.so/react-e1ef988c4cf3476fa2e48ac004eb5461)

<aside>
💡 React是**用于构建用户界面的 JavaScript 库**, 由facebook开源, 是前端工程师必须要掌握的框架

</aside>

# React简介

- react的三大特性: 声明式 组件化 跨平台
    
    声明式: 数据驱动视图, 数据变动时 React 能高效更新并渲染合适的组件。
    
    组件化: 构建管理自身状态的封装组件，然后对其组合以构成复杂的 UI。
    
    跨平台: 
    
    1. react-dom(web端) react-native(移动端) react-reavt360(VR), 
    2. 无论项目现在的技术栈是什么, 都可以通过引入 React 来开发新功能
- react元素: react渲染视图的最小单位
    
    在react中, React 元素是创建开销极小的JavaScript对象, 是渲染视图的最小单位
    
    - 如何创建React对象?
        
        ```jsx
        import React from 'react'
        let el = React.createElement(
          'h1', // 节点的类型
          { className: 'title', data: 'react-css' }, // 节点所拥有的属性
          'Hello, world!' // 节点的内容或子节点
        )
        ```
        
    - `React.crateElement` 会预先检查代码错误.然后创建一个JavaScript对象.
        
        ```jsx
        // 注意：这是简化过的结构
        const  el =
        {
        	type:'h1', // 节点类型
        	props:{    // 节点接收的属性
        		className:'greeting',
        		children:'Hello, world!' // 子节点的内容, 可以是字符串或者是其他el节点
        	}
        }
        ```
        
- `react-dom`库: 通过 `ReactDOM.render` 将react元素生成真实的DOM元素,并且渲染出来
    
    ```jsx
    import React from 'react'
    import ReactDOM from 'react-dom' 
    		 
    // 1.生成react元素
    let li = 'hello,world'
    let el = React.createElement(
      'h1',
      { className: 'title', data: 'react-css' },
      li,
    )
    
    // 2.调用ReactDOM.render来渲染UI
    ReactDOM.render(el, document.getElementById('root'))
    ```
    

# JSX的使用

react项目开发脚手架命令 `npx create-react-app 项目名称`

- JSX是JavaScript语法的扩展, 本质上依然是JavaScript
    
    JSX像模板语法, 但它具有JS的全部功能, 因为react.createElement()创建元素过于繁琐, 所以发明JSX写来XML. 这就是JSX. 
    
    JSX是通过 `Babel` 来转译成 React.createElement() 函数调用。
    
- JSX中嵌入表达式
    
    ### 在 JSX 语法中，可以在大括号内放置任何有效的JS表达式
    
    ```jsx
    	 (JS表达式: 任何值或者最终通过计算返回一个值, 可以通过console.log()打印的都是表达式)
    	let name = ' wx '
    	let el = <h1> 你好,{name} </h1>
    	ReactDOM.render(
    	  el ,
    	  document.getElementById('root')
    	);
    { /* 这是注释 */ }
    ```
    
    ### JSX本身也是一个表达式
    
    编译后JSX会是一个函数的调用(`React.createElement`), 取值后得到一个普通JS对象, 所以,可用通过操作对象一样使用JSX (比如函数中返回一段JSX).
    
    ```jsx
    function () {
    	return <div>123</div>
    }
    ```
    
    ### JSX中的特定属性
    
    ```jsx
    1. 通过使用引号，来将属性值指定为字符串字面量
    let el = <h1 className='title'> 你好,{ name } </h1>
    	
    2. 通过大括号{} ,可在属性值中插入JS表达式
    import logo from './logo.png'
    let img = <img src={ logo }></img>
    ```
    
- JSX使用的注意事项(react中)
    1. 必须要导入react, 因为JSX本质上是react.createElement(), (react17版本后,可以不需要导入)
    2. 必须要有一个根元素包裹起来, react支持<></>包裹(幽灵节点,会被解析成<React.Fragment>)
    3. 标签必须闭合!!!
    4. JSX更接近JavaScript, class属性要永className,for属性要使用htmlFor( <label htmlFor/> )
    5. 换行时最好用括号()包裹起来, 以防止意外的bug
- JSX中完成 `vue` 的各种语法糖 `v-if v-for class和style的处理`
    
    ### 条件渲染 ( if/else , 三元运算符, && 来完成条件渲染)
    
    1. if/else
        
        ```jsx
        let loading = true
        const reactH = loading => {
          if (loading) {
            return <li>loading为true</li>
          } else {
            return <div>loading为false</div>
          }
        }
        ```
        
    2. 三元运算
        
        ```jsx
        *const* el = <div>{loading ? <div>正在加载中...</div> : <div>加载完成</div>}</div>
        ```
        
    3. 逻辑运算
        
        ```jsx
        *const* element = loading && <div>正在加载中...</div>
        ```
        
    
    ### 列表渲染 (使用Array.map: 不改变原值, 且会返回一个新数组)
    
    ```jsx
    const list = ['太阳', '月亮', '星星']
    const dom = (
      <ul>
        {list.map((item, index) => {
          return <li key={index}> { item } </li> 
    			// 需要使用key来进行唯一标识, 方便更新时节省性能 diff更新
        })}
      </ul>
    )
    ```
    
    ### 样式处理
    
    1. style必须要是对象 不能是字符串
    2. 导入css文件 设置className
    
    ```jsx
    const div = (
      <ul>
        {list.map((item, index) => (
          <li key={index} style={{ fontSize: 30, color: 'red' }}>
            {item}
          </li>
        ))}
      </ul>
    )
    ```
    
- 使用 `classnames` 库来处理 class样式
    
    ```jsx
    import classNames from 'classnames'
    // classNames是一个函数 ---  和vue的class用法较为相似
     <span className={classNames('hate', { 'hated': item.attitude === -1 })}
     onClick={() => clickIcon(item.id, item.attitude === -1 ? 0 : -1)} />
    ```
    

# 组件和组件状态

- react中组件使用规范
    1. 组件名称必须大写字母开头, 小写视为原生DOM对象
    2. 必须有返回值, 没内容返回 `null`
- **函数组件**: 函数组件没有生命周期, 消耗更小,渲染更快.
    
    ```jsx
    // 1. function声明
    function Open(props) {
      return <h1>react,{props.name}</h1>
    }
    // 2.箭头函数
    const FnCom = () => <div>div</div>
    
    ReactDOM.render(
      <Open name='小王'/>,
      document.getElementById('root')
    )
    ```
    
- **类组件**:
    
    ```jsx
    import React, { Component } from 'react'
    class Open extends Component {
      render() {
        return <h1>Hello, {this.props.name}</h1>;
      }
    }
    ReactDOM.render(
      <Open name='小王'/>,
      document.getElementById('root')
    )
    ```
    
- 组合组件: 类组件和函数组件可以结合使用
    
    ```jsx
    class Open extends React.Component {
      render() {
        return <h1>Hello, {this.props.name}</h1>;
      }
    }
    function App() {
      return  <div>
        <Open name='哈哈'></Open>
        <Open name='wx'></Open>
        <Open name='66'></Open>
      </div>
    }
    ReactDOM.render(
      <App/>,
      document.getElementById('root')
    )
    ```
    
- **类组件和函数组件的区别**
    1. 函数组件也叫无状态组件,不能自己提供状态 (react 16.8版本 hooks出现之前)
    2. 类组件又叫有状态组件 可以自己提供数据. 状态就是 组件的私有数据,数据变化,状态更新
    3. hooks之前, 类组件比函数组件功能更强大 hooks之后,功能相同

# 类组件: 提供和修改组件状态

- 提供状态:  提供 `state` 通过 `this.state.xxx` 访问
    
    ```jsx
    class Demo extends Component {
      state = {  // state 提供状态
        count: 0,
        name: 'x2',
        salary: 100,
        list: ['test', 'demo'],
      }
      render() {
        return (
          <div>
            <p>数量:{this.state.count}</p>
            <p>金钱:{this.state.salary}</p>
            <ul>
              {this.state.list.map((item, index) => (
                <li key={index}>{item}</li>
              ))}
            </ul>
          </div>
        )
      }
    }
    
    // 完整写法
    class Parent extends React.Component{
        constructor(props){ // 提供constructor, 调用super()
            super(props)
            this.state = {name:'frank'}
        }
        onClick = () => {
            render(){
                return <B name={this.state.name} onClick={this.onClick}>hi</B>
            }
        }
    		render() {
    			return <div>Parent组件</div>
    		}
    }
    ```
    
- 注册事件: 修改组件状态 + 获取事件对象
    
    ```jsx
    render() {
        return (
          <div>
            <p>
              数量:{this.state.count}{' '}
              **<a onClick={this.addCount} href='http://www.baidu.com'> 
    						// 注意这段代码实际上有问题, this的指向问题**
                点击
              </a>
            </p>
            <p>金钱:{this.state.salary}</p>
            <ul>
              {this.state.list.map((item, index) => (
                <li key={index}>{item}</li>
              ))}
            </ul>
          </div>
        )
      }
      // 获取事件对象
      addCount(e) {
        e.preventDefault()
        e.stopPropagation()
        console.log('点击事件')
        // this.state.count++
      }
    }
    ```
    
- **class组件中的 `this` 指向问题**
    
    ### 回顾this指向问题:  `this` 的指向和调用方式有关
    
    1. 函数调用模式下, 匿名函数,定时器, this指向window对象(非严格模式下)
    2. 方法调用模式下, this指向调用方法的对象
    3. 事件处理函数中, this指向触发事件的当前元素
    4. 构造函数调用下, this指向新创建的实例
    5. 箭头函数中没有this指向问题, this始终和父级作用域保持一致
    6. 上下文调用模式下:
        1. call和apply方法中, this指向方法中的第一个参数. 
        2. bind方法中,bind创建的新函数的this绑定为bind方法中新的函数
    
    ### React中class组件的 `this` 问题
    
    1. 在react中 `render`函数中 `this` 没有问题, 指向react当前组件, 只有事件中的 `this` 存在问题,指向  `undefined`
    2. render中函数是直接被react组件调用的, this指向当前react组件
    3. 事件被赋值给onClick onClick调用this为undefined
    
- 解决class组件的 `this` 指向问题
    1. 在箭头函数中调用事件处理函数, 缺点结构不好 注意事件对象
        
        ```jsx
        <a onClick={(e) => {
             this.addCount(e)
           }}
            href='http://www.baidu.com'>
            点击
          </a>
        ```
        
    2. bind绑定事件处理函数改变this指向:  不使用call和apply, 会调用该函数
        
        ```jsx
        <a onClick={this.addCount().bind(this)} >
        	  点击
        </a>
        ```
        
    3. 直接将事件函数写为箭头函数 (推荐此写法// 实验性语法,通过Babel转义)  class中写箭头函数
        
        ```jsx
        addCount = (e) => {
            e.preventDefault()
            e.stopPropagation()
            console.log('点击事件')
            // this.state.count++ 
        		// 这里如何修改state状态 ?? 
          }
        ```
        
- 修改 `state` 状态: 使用 `setState` 方法
    
    React中直接修改数据并不会造成DOM主动更新
    
    必须通过调用this.setState方法来修改state的状态,同时React会触发DOM自动更新
    
    ```jsx
    addCount = e => {
      e.preventDefault()
      this.setState({
        count: this.state.count + 1,
      })
    }
    ```
    
- React核心理念: **状态不可变! 不要直接修改状态,而是创建新的状态值替换原来的状态**
    
    ```jsx
    addCount = e => {
      e.preventDefault()
      this.setState({
    		...this.state,
        count: this.state.count + 1,
      })
    }
    ```
    

# 类组件: 控制表单

**React中有两种控制表单的方法**

- 受控组件(推荐)
    - 表单元素的value值受到react组件状态的控制
    - 必须提供onChange事件. 使表单完全受到state的控制
    
    ```jsx
    	state = {
        value: '13',
        isDog: false,
      }
      render() {
        return (
          <div>
            <div>受控组件</div>
            <input
              type='text'
              value={this.state.value}
              onChange={this.handerChange}
            />
            <label htmlFor='isDog'>是否单身</label>
            <input
              type='checkbox'
              id='isDog'
              checked={this.state.isDog}
              onChange={this.handleDog}
            />
          </div>
        )
      }
      handerChange = e => {
        this.setState({
          value: e.target.value,
        })
      }
      handleDog = e => {
        this.setState({
          isDog: e.target.checked,
        })
      }
    ```
    
- 非受控组件(不推荐, 适合用来调用组件的方法)
    - 通过 `createRef` 创建 `ref` 对象来获取DOM, 操作原生DOM的方式来更新数据.
    - 通过调用 `ref` 的 `current` 属性可获取当前元素/组件
    
    ```jsx
    import React, { Component, createRef } from "react"
    	import ReactDOM from "react-dom"
    	
    	class App extends Component {
    	  state = {
    	    value: '',
    	    checked: false
    	  }
    	  oneRef = createRef()
    	  render () {
    	    return (
    	      <div>
    	        <p>受控组件(推荐)</p>
    	        姓名 <input type='text' value={this.state.value} onChange={this.handleInput} />
    	        <p>非受控组件,使用ref获取组件或dom</p>
    	        <label htmlFor="checkbox"> 是否单身 </label>
    	        <input id="checkbox" type='checkbox' ref={this.oneRef} onChange={this.handleCheckbox}></input>
    	      </div>
    	    )
    	  }
    	  handleInput = (e) => {
    	    this.setState({
    	      value: e.target.value
    	    })
    	  }
    	  handleCheckbox = () => {
    	    this.setState({
    	      checked: this.oneRef.current.checked
    	    })
    	  }
    	}
    	ReactDOM.render(<App></App>, document.querySelector('#root'))
    ```
    

# 类组件: 事件函数传参

- bind绑定事件处理函数: bind方法的第一个参数绑定this, 后续参数作为新函数的入参
    
    ```jsx
    onClick={this.clickTab.bind(this,item.type)}
    
    clickTab = (type) => {
        this.setState({
    			active: type
        })
    }
    ```
    
- 在箭头函数中调用传参的事件处理函数: 不能在render执行时直接调用函数
    
    ```jsx
    onClick={() => this.delItem(item.id)}
    
    delItem = (id) => {
      this.setState({
        list: this.state.list.filter(item => item.id !== id)
      })
    }
    ```
    

# 组件通讯

打破组件间的封闭性, 让其与外界共享数据

- `props` 的基本使用
    
    `props`是只读对象, 父组件的数据更新会流到子组件,子组件不能直接修改父组件的数据. 要符合 `单项数据流`
    
    1. 函数组件: 通过函数入参 获取props
        
        ```jsx
        function App ( props ) {
           return (
             <div>
               我是App组件
               <p>名称: {props.name} </p>
               <p>身高: {props.length || 170} </p>
             </div>
           )
        }
        
        ReactDOM.render(<App name='appppp' length={190} />, document.getElementById('root'))
        ```
        
    2. class组件: 通过 `this.props` 获取父组件传递的数据
        
        ```jsx
        class App extends Component {
          render () {
            return (
              <div>
                我是App组件
                <p> name: { this.props.name } </p>
                <p> length: { this.props.weight } </p>
              </div>
            )
          }
        }
        
        ReactDOM.render(<App name='appppp' length={190} />, document.getElementById('root'))
        ```
        
    
- `**props` 的 `children` 属性**
    1. children属性：表示该组件的子节点，只要组件有子节点，props就有该属性
    2. children 属性与普通的props一样，值可以是任意值（文本、React元素、组件，甚至是函数）
    3. 例子
        
        ```jsx
        function Hello (props) {
          return (
            <div>
              该组件的子节点：{props.children}
            </div>
          )
        }
        ReactDOM.render(<Hello>我是子节点</Hello>, document.getElementById('root'))
        ```
        
- 父传子
    
    ```jsx
    // 没有逻辑 建议使用函数组件
    `Son.jsx`
    function Son (props) {
      return (
        <li className='child'>
          <p>名称: {props.item.name}</p>
          <p>价格: {props.item.price}</p>
          <p>折扣: {props.item.info}</p>
        </li>
      )
    }
    export default Son
    	
    `App.js`
    import { Component } from 'react'
    import Son from './Son.jsx'
    class App extends Component {
      state = {
        name: 'App组件',
        list: [
          { id: 1, name: '棒棒糖', price: 18.8, info: '全场8折' },
          { id: 2, name: '大鸡腿', price: 34.2, info: '全场6折' },
          { id: 3, name: '冰激凌', price: 14.2, info: '全场7折' }
        ]
      }
      render () {
        return (
          <div className='parent'>
            我是App组件
            <ul>
              {this.state.list.map(item => <Son key={item.id} item={item} />)}
            </ul>
          </div>
        )
      }
    }
    export default App
    ```
    
- 子传父
    
    利用回调函数，父组件提供回调修改状态, 并且将修改状态的函数传给子组建，子组件调用，将要传递的数据作为回调函数的参数。
    
    ```jsx
    `App.jsx`
    import { Component } from 'react'
    import Son from './Son.jsx'
    class App extends Component {
      state = {
        name: 'App组件',
        list: [
          { id: 1, name: '棒棒糖', price: 18.8, info: '全场8折' },
          { id: 2, name: '大鸡腿', price: 34.2, info: '全场6折' },
          { id: 3, name: '冰激凌', price: 14.2, info: '全场7折' }
        ]
      }
      cutPrice = (id, value) => {    // 提供函数修改自身的状态
        this.setState({
          list: this.state.list.map(item => {
            if (item.id === id) {
              return {
                ...item,
                price: value
              }
            } else {
              return item
            }
          })
        })
      }
      render () {
        return (
          <div className='parent'>
            我是App组件
            <ul>
              {this.state.list.map(item => <Son key={item.id} item={item} cutPrice={this.cutPrice} />)} // 将函数传给子组件,让子组件调用
            </ul>
          </div>
        )
      }
    }
    export default App
    
    `Son.jsx`
    import { Component } from "react"
    // 没有逻辑 建议函数组件
    class Son extends Component {
      render () {
        return (
          <li className='child' >
            <p>名称: {this.props.item.name}</p>
            <p>价格: {this.props.item.price}</p>
            <p>折扣: {this.props.item.info}</p>
            <button onClick={this.cutParentPrice.bind(this, this.props.item.id, this.props.item.price)}>砍价</button> // 调用父组件给的函数去修改父组件数据
          </li>
        )
      }
      cutParentPrice = (id, price) => {
        this.props.cutPrice(id, price - 1)
      }
    }
    export default Son
    ```
    
- 兄弟组件通讯
    
    利用状态提升 将共享状态提升到最近的公共父组件中，由公共父组件管理这个状态
    
    ```jsx
    App.jsx
    import { Component } from 'react'
    import Son from './Son.jsx'
    import Son1 from './Son1.jsx'
    class App extends Component {
      state = {
        num: 9999
      }
      render () {
        return (
          <div className='parent'>
            <div>我是App组件</div>
            <Son num={this.state.num} changeNum={this.changeNum}></Son>
            <Son1 num={this.state.num} changeNum={this.changeNum}></Son1>
          </div>
        )
      }
      changeNum = (newValue) => {
        this.setState({
          num: newValue
        })
      }
    }
    export default App
    
    Son,jsx
    import { Component } from "react"
    // 没有逻辑 建议函数组件
    class Son extends Component {
      render () {
        return (
          <div>
            Son组件 ： {this.props.num}
            <button onClick={this.add.bind(this)}>++</button>
          </div>
        )
      }
      add = () => {
        this.props.changeNum(this.props.num + 1)
      }
    }
    export default Son
    
    Son1.jsx
    import { Component } from "react"
    class Son1 extends Component {
      render () {
        return (
          <div>
            Son1组件 ： {this.props.num}
            <button onClick={this.cut.bind(this)}>--</button>
          </div>
        )
      }
      cut = () => {
        this.props.changeNum(this.props.num - 1)
      }
    }
    export default Son1
    ```
    
- 跨级组件通讯 `Context`
    
    类似于 vue的 private 和 inject 使用的较少.了解即可 重点学习Redux
    
    使用步骤
    
    1. 导入 `createContext` 方法
        
        ```jsx
        import { Component, createContext } from "react"
        const { Provider, Consumer } = createContext()
        ```
        
    2. 使用 `Provider` 包裹父组件, 并通过 `value` 属性提供要共享的数据
        
        ```jsx
        const Context = createContext()
        class App extends Component {
        	  state = {
        	    num: 9999
        	  }
        	  render () {
        	    return (
        	      <Context.Provider value={{ num: this.state.num }}>
        	        <div className='parent'>
        	          <div>我是App组件</div>
        	          <Son></Son>
        	        </div>
        	      </Context.Provider>
        	    )
        	  }
        	}
        export { Context }
        export default App
        ```
        
    3. 下级组件引入上级组件中创建的Context对象, 提供函数, 函数入参为上级组件共享的value值
        
        ```jsx
        import { Context } from './App' 
        	// 没有逻辑 建议函数组件
        	class Son extends Component {
        	  render () {
        	    return (
        	      <Context.Consumer>
        	        {
        	          (data) => <div>  // 注意: 这里要提供一个函数来获取共享的状态
        	            Son组件 ：{data.num}
        	          </div>
        	        }
        	      </Context.Consumer>
        	    )
        	  }
        }
        ```
        

# 组件通讯: `prop-types` 类型校验库的使用

- 使用 `prop-types` 库 来完成 `props` 的数据类型校验
    1. 导入 `prop-types` 包
        
        ```jsx
        import PropTypes from 'prop-types'
        ```
        
    2. 使用组件名.propTypes = {} 来给组件的props添加校验规则
        
        ```jsx
        function App (props) {
        	  return (
        	    <h1>Hi, {props.colors}</h1>
        	  )
        	}
        
        	App.propTypes = {
        	  colors: PropTypes.array
        	  // 约定colors属性为array类型
        	  // 如果类型不对，则控制台报出错误，便于分析错误原因
        }
        ```
        
- `props` 的校验规则
    1. 常见类型：array、bool、func、number、object、string
    2. React元素类型：element
    3. 必填项：isRequired
    4. 特定结构的对象：shape({})
    
    ```jsx
    import ReactDOM from 'react-dom'
    import PropTypes from 'prop-types'
    
    function App (props) {
      return (
        <h1 style={props.colors}>Hi,</h1>
      )
    }
    App.propTypes = {
      colors: PropTypes.shape({               // colors是固定形状的对象
        color: PropTypes.string,              // string
        fontSize: PropTypes.number.isRequired // 必须 且 number 链式调用
      })
    }
    ReactDOM.render(<App colors={{ color: 'red', fontSize: 60 }}></App>, document.getElementById('root'))
    ```
    
- `props` 的默认值
    
    使用 `defaultProps`
    
    ```jsx
    function App (props) {
      return (
        <h1 style={props.colors}>Hi,</h1>
      )
    }
    App.propTypes = {
      colors: PropTypes.shape({
        color: PropTypes.string,              // string
        fontSize: PropTypes.number.isRequired // 必须num
      })
    }
    App.defaultProps = {
      colors: {
        color: 'blue',
        fontSize: 90
      }
    }
    ReactDOM.render(<App></App>, document.getElementById('root'))
    ```
    
- **使用class关键字 `static` 来简化写法**
    
    ES6提供 `static` 修饰符, 修饰的方法称为静态方法, 它们不需要实例化, 而是直接通过类来调用
    
    ```jsx
    class App extends Component {
      render() {
        return <h1 style={this.props.colors}> Hi,</h1>
      }
      static propTypes = {
        colors: PropTypes.shape({
          color: PropTypes.string, // string
          fontSize: PropTypes.number.isRequired, // 必须num
        }),
      }
      static defaultProps = {
        colors: {
          color: 'pink',
          fontSize: 12,
        },
      }
    }
    ```
    

# 类组件: 生命周期

生命周期: 组件在挂载后的不同阶段

只有 `类组件` 才有生命周期. 函数组件不存在生命周期(函数组件性能消耗小)

- 类组件生命周期的 三个阶段, 五个钩子函数
    1. 挂载阶段 constructor render componentDidMount
    2. 更新阶段 render componentDidUpdate
    3. 卸载阶段 componentWillUnmount
    
    ```jsx
    // 全部的生命周期函数
    1. constructor() 
    // 创建之后 初始化props,state,但此时不能调用 setState,用来bind this
    2. static getDerivedStateFromProps() 不常用
    3. shouldComponentUpdate() 
    // 更新组件吗？ 返回布尔值 return false 阻止更新/ return true 更新
    // shouldComponentUpdate有什么用?
    // 答: 它允许我们手动判断是否要进行组件更新，我们可以根据应用场景灵活地设置返回值，
    //     以避免不必要的更新, 节省性能
    render() 渲染了 创建虚拟DOM
    getSnapshotBeforeUpdate() 不常用
    componentDidMount() 组件已经挂载后
    componentDidUpdate() 组件已经更新后
    componentWillUnmount() 组件将要卸载时
    static getDerivedStateFromError() 不常用
    componentDidCatch() 不常用
    ```
    
- 挂载阶段: `constructor` `render` `componentDidMount`
    1. `constructor`是最先执行,用来提供初始化数据
    前面已经说过, class组件的完整写法, `state`应该在 `constructor`中提供
    2. `render`用来渲染虚拟UI , 不能在render中更新状态, 会造成死循环.
    3.  `componentDidMount` 组件已经挂载完成,DOM已渲染, 在这里可以获取到DOM元素, 一般在这里发送ajax请求
- 更新阶段: `render` `componentDidUpdate`
    1. 会再次触发render函数, 触发DOM的更新
        
        什么时候会触发 `render`
        
        1. 初始化数据, 组件第一次渲染
        2. 父组件的props数据发生改变
        3. 组件自身的状态发生改变, 调用setState时
        4. 调用 `forceUpdate`API 触发react组件强制更新
    2. `componentDidUpdate` 每次DOM更新后操作最新DOM时调用,  注意不能在这里调用 `setState` 和`forceUpdate` 避免触发死循环
- 销毁阶段: `componentWillUnmount`
    
    卸载DOM,销毁全局资源: 定时器或者挂载window上的一些事件等
    
- 其他生命周期函数
    
    `shouldComponentUpdate` : 更新阶段执行, 用于判断组件是否更新 (性能优化篇)
    

# `**setState` 的额外说明**

- `setState` 是同步还是异步的问题
    
    首先说结论: `setState` 虽然表现出异步的特性, 但是他是同步的
    
- `setState` 的异步特性: 调用 `setState` 后立即打印或者获取 `state` 值, 为原来的值
    
    在调用 `setState` 的时候 react会把所有的`setState` 放到自己的一个任务队列中, 并不是js的异步队列
    react会将所有的 `setState` 合并到一个setState中去调用, 这是react自身的性能改进
    
    ```jsx
    import { Component } from 'react'
    import ReactDOM from 'react-dom'
    class App extends Component {
      state = {
        count: 0,
      }
      render() {
        return (
          <div>
            <h1>{this.state.count}</h1>
            <button onClick={this.addCount}>增加count</button>
          </div>
        )
      }
      addCount = () => {
        this.setState({
          count: this.state.count + 1,
        })
        console.log(this.state.count) // 点击后值为 0
        console.log(document.querySelector('h1').innerText) // 同样为0
      }
    }
    ReactDOM.render(<App></App>, document.getElementById('root'))
    ```
    
- `setState` 进阶: 提供函数形式(入参为上一次 `state` 的值), 证明异步特性
    
    ```jsx
    import { Component } from 'react'
    import ReactDOM from 'react-dom'
    class App extends Component {
      state = {
        count: 0,
      }
      render() {
        return (
          <div>
            <h1>{this.state.count}</h1>
            <button onClick={this.addCount}>增加count</button>
          </div>
        )
      }
      addCount = () => {
    
        this.setState(pre => { // pre: 0
          return {
            count: pre.count + 1,
          }
        })
        this.setState(pre => { // pre: 1
          return {
            count: pre.count + 1,
          }
        })
    
        console.log(this.state.count) // 点击后值为 0
        console.log(document.querySelector('h1').innerText) // 同样为0
      }
    }
    ReactDOM.render(<App></App>, document.getElementById('root'))
    ```
    
- `**setState` 的第二个参数: 函数, 会等待 `setState` 执行后调用**
    
    ```jsx
    import { Component } from 'react'
    import ReactDOM from 'react-dom'
    class App extends Component {
      state = {
        count: 0,
      }
      render() {
        return (
          <div>
            <h1>{this.state.count}</h1>
            <button onClick={this.addCount}>增加count</button>
          </div>
        )
      }
      addCount = () => {
    	// setState第一个参数为 updater函数, 第二个为回调函数
        this.setState(
          {
            count: this.state.count + 1,
          },
          () => {
            console.log('会等待updater执行后才执行') // setState 执行后的回调
            console.log(this.state.count) // 点击后值为 1
            console.log(document.querySelector('h1').innerText) // 同样为 1
          },
        )
        console.log(this.state.count) // 点击后值为 0
      }
    }
    ReactDOM.render(<App></App>, document.getElementById('root'))
    ```
    
- 总结 `setState` 的特点
    - `setState`虽然表现出的是异步特征,但它实际上是同步的.
    - react本身有一个性能优化机制,调用 `setState` 时,react不会立刻去更新数据(如果立刻更新,组件会立刻更新,浪费性能),它会把同一个周期内或者同一个事件处理函数内的所有 `setState` 合并成一个之后在延迟调用
    - 如果我们在 `setTimeout/setInterval` 或者原生的事件中/甚至是 `async,await` 下调用 `setState`,它表现出来是同步的, 因为react处理不了这类情况, 上下文缺失. react18中优化掉了(表现一致)
    - `setState` 的异步特征和 `JavaScript`的微任务和宏任务没有任何关联. 它就是 `react`自己的一个内部的性能优化 , 表现出异步特征而已
- [https://www.notion.so/React-9610e7e391874a7e9772e193899906f9#b6ae6a4c042140ef9930cecb31eb4199](https://www.notion.so/React-9610e7e391874a7e9772e193899906f9)

# 函数组件(React16.8版本): `Hooks` 来袭

- `hooks` 函数严格规定 以 `use` 开头
- `hooks` 是什么? 给函数组件带来了什么?
    - `hooks` 为函数组件提供状态, 生命周期和原本在类组件中才能实现的 React 功能
    - 基本上可以理解为通过 `hooks` 为函数组件钩入了类组件的所有特性, 从此以后, 函数组件不再是无状态组件了. 现在, 函数组件和类组件有同样的能力
- `react` 为什么推出了 `hooks` ?
    1. 在没有 `hooks` 之前, 使用组件时, 需要考虑类组件合适还是函数组件合适
    2. 需要理解类组件的 `this` 
    3. 相同逻辑是被拆分到不同生命周期函数中的, 不利于逻辑复用
    4. 类组件不利于代码压缩和优化(树摇), 不利于ts类型推断(this)

# 函数组件: `hooks` 的使用

- `hooks` 使用注意事项
    1. 多次调用 提供状态, 逻辑写到一起
    2. `hooks` 函数只能在函数组件中调用, 普通函数不可使用
    3. `hooks` 函数不能写在if/else中
    4. react是按照 `hooks` 函数的调用顺序来识别每一个hook的
- `useState`
    - `useState` 为函数组件提供状态
        
        使用步骤: 
        
        1. 从react中倒入要使用的 `hook`
            
            ```jsx
            import React, { useState } from 'react'
            ```
            
        2. 在函数组件中调用(也只能在函数组件中使用) , 并传入初始值
            
            ```jsx
            import { useState } from 'react'
            	export default function App() {
            	  const count = useState(0)
            	  console.log(count)
            		 // [0,f(){}]
            		 // count是一个数组, 第0项是初始状态, 第一项是一个函数,用于修改状态(新值替换旧值)
            	  return <div>123</div>
            }
            
            // 一般会使用数组解构的方式来简化使用
            import { useState } from 'react'
            export default function App() {
              const [count, setCount] = useState(0)  // 数组的结构 
              return (
                <div>
                  <div>{count}</div>
                  <button onClick={() => setCount(count + 1)}>点击</button>
                </div>
              )
            }
            
            //  受控组件
            import React, { useState } from 'react'
            export default function App () {
              const [value, setValue] = useState('') // '' 为初始值
              return (
                <div>
                  <input type="text" value={value} onChange={(e) => setValue(e.target.value)} />
                </div>
              )
            }
            ```
            
    - 使用 `**useState`, 组件的更新过程 ( 函数组件没有所谓的生命周期 )**
        1. 先从头开始执行组件中的代码逻辑( 可以理解为调用一次该函数 )
        2. 调用 `useState()` 后, 将传入的值作为初始值
        3. 渲染当前组件, 此时获取到初始值
        4. 调用 `useState()[1]` 函数来修改状态后, 再次调用 `useState`, 此时react内部会拿到最新状态
        5. 函数再次调用, 组件再次渲染(新状态)
        6. 证明: `useState` 中可以提供函数,实现逻辑,比如初始值需要行本地获取的情况
            
            ```jsx
            import React, { useState } from 'react'
            	function handleClick (value, setValue) {
            	  console.log(value)
            	  setValue(value + 1)
            	}
            	export default function App () {
            	  const [value, setValue] = useState(() => {
            	    console.log('调用useState') // 只会在初始化时调用一次
            	    return 0
            	  })
            	  return (
            	    <div>
            	      <input type="text" value={value} onChange={(e) => setValue(e.target.value)} />
            	      <button onClick={() => handleClick(value, setValue)}>点我</button>
            	    </div>
            	  )
            }
            ```
            
    - `useState` 用useState(回调函数)形式提供初始值 useState(() => { return 初始值 })
        1. 回调函数的返回值就是状态的初始值
        2. 该回调函数只会触发一次, 适用于需要一段逻辑来获取初始值的情况(比如本地获取)
            
            ```jsx
            const [list, setList] = useState(() => {
              return JSON.parse(localStorage.getItem('comments')) || comments
            })
            ```
            
    
- `useEffect`
    
    用来处理函数组件中的副作用:
    
    对于react组件来说，除了渲染UI之外的其他操作，都可以称之为副作用(操作dom.ajax等)
    
    - `useEffect` 的使用方法: `useEffect` 在组件渲染后和组件更新后执行
        
        ```jsx
        import { useEffct } from 'react'
        
        useEffect(() => {
        	console.log('useEffct执行了')
        })
        ```
        
    - `useEffect` 依赖项
        1. useEffct第二参数是一个数组, 可以提供回调函数调用的依赖值, 可以依赖多个值
            
            ```jsx
            import React, { useEffect, useState } from 'react'
            function handleClick (value, setValue) {
              setValue(value + 1)
            }
            export default function App () {
              const [value, setValue] = useState(0)
              const [count, setCount] = useState(0)
              **useEffect(() => {
                document.title = value
              }, [value]) // 只有依赖的value状态改变, 回调才会执行**
              return (
                <div>
                  <input type="text" value={value} onChange={(e) => setValue(e.target.value)} />
                  <button onClick={() => handleClick(value, setValue)}>点我</button>
                  <div>{count}</div>
                  <button onClick={() => setCount(count + 1)}>add</button>
                </div>
              )
            }
            ```
            
        2. 当依赖为空数组时, useEffct回调只在组件初次渲染后执行一次
            
            ```jsx
            // 使用场合
            // 1 事件绑定 
            // 2 发送请求获取数据 等
              useEffect(() => {
                window.onresize = function (e) {
                  console.log(window.innerWidth)
                }
              }, [])
            ```
            
        3. 当不存在依赖项时, 每次组件更新都会调用, 也可以说依赖所有状态
        4. **不要对依赖项撒谎**
        当回调函数依赖到一些状态时务必提供该依赖, 如果不提供对应依赖,可能会导致状态更新错误
    - `useEffect` 进阶: 清除副作用
        
        什么是副作用: 组件卸载时清理事件
        
        `useEffect` 的返回值是可选的。可以返回一个清理函数，用来执行事件解绑等清理操作
        
        ```jsx
        useEffect(() => {
            const handleResize = () => { }
            window.addEventListener('resize', handleResize)
            // 这个返回的函数，会在该组件卸载时来执行
            // 因此，可以去执行一些清理操作，比如，解绑 window 的全局事件、清理定时器等
            return () => window.removeEventListener('resize', handleResize)
          })
        ```
        
        清理函数的执行时机:
        
        1. 清理函数会在组件卸载时以及下一次副作用回调函数调用的时候执行，用于清除上一次的副作用。
        2. 如果依赖项为空数组，那么会在组件卸载时会执行。相当于组件的componetWillUnmount
            
            ```jsx
            useEffect(() => {
              window.onresize = () => {
                console.log(window.innerWidth)
              }
              return () => window.onresize = null
            }, [])
            ```
            
    - 在 `useEffect` 中发送 `ajax` 请求
        
        **effect 只能是一个同步函数，不能使用 async**
        
        1. 如果 effect 是 async 的，此时返回值是 Promise 对象。这样的话，**就无法保证清理函数被立即调用**
        2. **为了使用 async/await 语法，可以在 effect 内部创建 async 函数，并调用**
            
            ```jsx
            useEffect(() => {
              async function fetchMyAPI() {
                let url = 'http://something/' + productId
                let config = {}
                const response = await myFetch(url)
              }
              fetchMyAPI()
            }, [productId])
            ```
            
- `useRef`
    - 使用 `useRef` 操作DOM, 或者操作类组件**(函数组件不能操作)**
        
        注意: 要使用 `useRef` 创建的 `ref` 对象的 `current` 属性
        
            在类组件中 `createRef` 创建 `ref` 对象
        
        ```jsx
        1. 创建ref对象
        	import React, { Component, useRef, useEffect } from 'react'
        	const ref = useRef(null)
        	
        2. 将ref关联到对应的dom或者class组件上
        	<Son ref={ref}></Son>
        
        3. 通过ref对象的current属性访问到该dom
        	import React, { Component, useRef, useEffect } from 'react'
        	class Son extends Component {
        	  state = {
        	    count: 0
        	  }
        	  add = () => {
        	    console.log(1);
        	    this.setState({
        	      count: this.state.count + 1
        	    })
        	  }
        	  render () {
        	    return (
        	      <div>
        	        <div>{this.state.count}</div>
        	        <button onClick={this.add}>按钮</button>
        	      </div>
        	    )
        	  }
        	}
        	export default function App () {
        	  const ref = useRef(null)
        	  useEffect(() => {
        	    ref.current.add()
        	  }, [])
        	  return (
        	    <div>
        	      123
        	      <Son ref={ref}></Son>
        	    </div>
        	  )
        }
        ```
        
    - `useRef` 的第二种用法: 突破闭包带来的限制
        
        `useRef` 会返回一个不可变的 `ref` 对象, 该对象的current属性是可变的
        
        这个 `ref` 对象可以贯串函数组件所有的快照, 而且 `ref` 的 `current` 属性改变, 函数组件不会更新
        
        场景: 定时器中修改状态
        
        ```jsx
        export default function useCountDown(time = 10, callback) {
          const [count, setCount] = useState(time)
          const timerRef = useRef(null)
        
          const start = () => {
            timerRef.current = setInterval(() => {
              console.log('定时器开始')
              setCount(count => count - 1) // 提供函数来获取上一个快照设置的值
            }, 1000)
          }
        
          useEffect(() => {
            if (count === 0) {
              callback && callback()
              console.log('清除定时器')
              clearInterval(timerRef.current)
              setCount(time)
            }
          }, [count])
        
          useEffect(() => {
            return () => {
              clearInterval(timerRef.current) // 组件卸载时，清除定时器
            }
          }, [])
          return { count, start }
        }
        
        const [time, setTime] = useState(5)
        const timeRef = useRef(time)
        useEffect(() => {
           let timerId = setInterval(() => {
             setTime(timeRef.current - 1)
             if (timeRef.current === 1) {
               clearInterval(timerId)
             }
           }, 1000)
           return () => {
             clearInterval(timerId)
          }
        }, [])
        
        useEffect(() => {
          timeRef.current = time
        }, [time])
        ```
        
    
    <aside>
    💡  注意: 如果, ref没有绑定React组件, 并且初始值为null, 那么ref对象和其current属性不可变(只读)
     解决: | null
    const refSocket = useRef<Socket | null>(null)
    
    </aside>
    
- `useContext`
    
    回顾 `Context` 的跨组件通讯的用法 : [https://www.notion.so/React-9610e7e391874a7e9772e193899906f9#e4f797a7251d4b85a4833ebc0bb59bc4](https://www.notion.so/React-9610e7e391874a7e9772e193899906f9)
    
    - `useContext` 和 `<Context.Consumer />`的区别
    1. `useContext` 在js代码中获取 `Context`共享状态.
    2. `<Context.Consumer />`在jsx中获取 `Context` 状态
        
        ```jsx
        import React, { Component, createContext, useContext } from 'react'
        const Context = createContext()
        function Son () {
          **const context = useContext(Context)  // 依然要配合createContext使用**
          console.log(context)
          return (
            <div>
              Son组件 :{context.count}
            </div>
          )
        }
        
        class Father extends Component {
          render () {
            return (
              <div>
                Father组件:{123}
                <Son></Son>
              </div>
            )
          }
        }
        
        export default class App extends Component {
          state = {
            count: 100
          }
          render () {
            return (
              <Context.Provider value={{ count: this.state.count }}>
                <div>
                  App组件 : {this.state.count}
                  <Father></Father>
                </div>
              </Context.Provider>
            )
          }
        }
        ```
        
- 自定义 `Hooks`: 实现状态的逻辑复用
    
    `Hooks` 只能在函数组件中或其他自定义 `Hooks` 中使用，否则会报错！
    自定义 `Hooks` 用来提取组件的状态逻辑，根据不同功能可以有不同的参数和返回值（就像使用普通函数一样）
    
    定义一个获取鼠标位置的hook
    
    ```jsx
    import React, { useState, useEffect } from 'react'
    export const useMousePosition = () => {
      const [position, setPosition] = useState({
        x: 0,
        y: 0
      })
      useEffect(() => {
        const getPosition = (e) => {
          setPosition({
            x: e.pageX,
            y: e.pageY
          })
        }
        document.addEventListener('mousemove', getPosition)
        return () => document.removeEventListener('mousemove', getPosition)
      }, [])
      return position
    }
    
    App.js
    import React, { useState, useEffect } from 'react'
    import { useMousePosition } from './hooks'
    export default function App () {
      const position = useMousePosition()
      return (
        <div>
          x:{position.x}
          y:{position.y}
        </div>
      )
    }
    ```
    
- `Hooks` 函数的特性
    1. 每次状态更新组件都会重新渲染
    2. 每次组件更新就像是在给组件拍照,每次更新就是一张照片,记录了组件在特定时刻的状态
    3. 组件每次更新都有自己独立的state/props/事件处理程序等
    4. 每次拍照的照片在代码层面来讲都是通过函数的闭包机制实现的
- `Hooks` 函数特性带来的问题 ⇒ react进阶 ⇒ 性能优化 ⇒ 函数组件
    1. 每次更新组件内处理程序获取到的是特定时刻的状态,如果是一个定时器修改了状态,那么我们拿到的不是最新的状态,而是那次特定时刻渲染的状态,虽然客观角度来说这是合理的(闭包机制的存在), 但是有时我们想拿到最新的状态,也就是定时器修改后的状态,那么我们就要使用 `useRef` 来解决
        
        解决: [https://www.notion.so/React-9610e7e391874a7e9772e193899906f9#4ccad9efcc9241f69af1f3a2e517e675](https://www.notion.so/React-9610e7e391874a7e9772e193899906f9)
        
    2. 每次更新组件内的事件处理程序等函数都会重新创建, 那么会造成子组件每次都接收到不同的props导致不必要的渲染性能浪费, 这时可以施用React.memo高阶组件和useMemo/useCallback解决(对于class组件,这个问题就可以通过PureComponent或者shouldComponentUpdate来解决)
    
    原因:
    
    父组件每次更新时,如果子组件props没有更新,那么就没必要进行重新渲染,但是react组件更新机制是父组件更新了子组件是无条件更新的,不管子组件有没有变化,所以我们要避免这个没必要的更新造成性能浪费
    
    解决:
    
    使用React.memo包裹的组件就可以被缓存下来,如果子组件props没有更新则还是用之前的缓存组件,memo在对比props的变化时使用的是浅层对比,所以想让其识别引用类型的props,我们更新状态的时候要更改props的栈引用,这点和PureComponent对比props的特性是类似的
    
    ```jsx
    import React, { useState } from 'react';
    const Child = React.memo(() => {
      console.log('子组件更新了...')
      return <div>我是子组件</div>
    })
    const Father = () => {
      const [count, setCount] = useState(0)
      return <div>
        <h1>{count}</h1>
        <button onClick={() => setCount(count + 1)}>+1</button>
        <button onClick={() => setCount(count - 1)}>-1</button>
        <Child />
      </div>
    }
    export default Father
    ```
    
    ```jsx
    const Child = React.memo(() => {
      console.log('子组件更新了...')
      return <div>我是子组件</div>
    },(prevProps,nextProps) => { 
      // 传入的参数就是变化前的props和变化后的props,用来给我们手动对比
      // return true就是不更新,使用缓存组件,return false就是更新
    })
    ```
    
    使用 `useCallback` 包裹函数,避免组件更新重新创建函数造成性能浪费
    
    ```jsx
    import React, { useCallback, useState } from 'react';
    const Child = React.memo(() => {
      console.log('子组件更新了...')
      return <div>我是子组件</div>
    })
    const Father = () => {
      let [count, setCount] = useState(0)
      // useCallback第二个参数和useEffect的差不多,也是决定是否触发的依赖项,填空数组就第一次渲染执行一次
      const callback = useCallback(()=>{
        console.log('按钮点击了',count)
      },[count])
      return <div>
        <h1>{count}</h1>
        <button onClick={callback}>点我</button>
        <button onClick={() => setCount(count + 1)}>+1</button>
        <button onClick={() => setCount(count - 1)}>-1</button>
        <Child />
      </div>
    }
    export default Father;
    ```
    
    使用useCallback后就可以缓存函数了,指定依赖让组件更新时只在依赖项变化时重新创建函数的实例
    
    使用空[数组](https://so.csdn.net/so/search?q=%E6%95%B0%E7%BB%84&spm=1001.2101.3001.7020)的结果就是不管count怎么变化输出的都是0,因为闭包函数没有重新创建过,里面的count仍然保留的是之前的count引用
    
    指定依赖项为count的时候,只有当count更新时才会重新创建,才能拿到最新的count值,所以此时输出的count才是期望的值
    
    tips:一般做缓存优化时都会将React.memo和useCallback成对使用来提高性能
    
    useMemo:
    
    useMemo用于缓存计算结果,他和useCallback不同之处就是useMemo用于缓存计算结果,他返回的是一个计算结果的值,而useCallback用于缓存函数,所以可以把useMemo理解成Vue中的计算属性computed,只有依赖项变化了才会更新缓存结果,提高效率,用法和useEffect差不多.
    
    ```jsx
    import React, { useCallback, useMemo, useState } from 'react';
    const Child = React.memo(() => {
      console.log('子组件更新了...')
      return <div>我是子组件</div>
    })
    const Father = () => {
      let [count, setCount] = useState(0)
      const callback = useCallback(() => {
        console.log('按钮点击了', count)
      }, [count])
      // 使用useMemo计算一个值返回
      const name = useMemo(() => {
        return `Suk-${count}`
      }, [count])
      return <div>
        <h1>{count}</h1>
        <button onClick={callback}>点我</button>
        <h3>名字:{name}</h3>
        <button onClick={() => setCount(count + 1)}>+1</button>
        <button onClick={() => setCount(count - 1)}>-1</button>
        <Child />
      </div>
    }
    export default Father;
    ```
    

# react进阶

### 实现逻辑复用

- `mixins(混入)` 逻辑复用(已废弃:了解)
    
    `mixins` 的缺点:
    
    1. 命名冲突
    2. 来源不清晰
    3. `minins` 相互依赖, 难以维护
    4. 逐渐增加代码复杂性
- `render props` 实现逻辑复用
    
    **指一种在React组件之间使用值为函数的prop共享代码的技术.**
    
    render props 是一种逻辑复用的模式, 传递一个函数类型的props来决定要渲染的内容(一般会命名为render或者children)
    
    - 小知识: react中 `JSX.Element` `React.ReactElement` `React.ReactNode` 区别
        
        `ReactNode` :
        
        可以是一个ReactElement，一个ReactFragment，一个string类型，一个number类型，或者是null，或者是boolean，或者是undefined，或者一个ReactNode的数组
        
        `ReactElement` :
        
        ReactElement是具有类型和属性的对象。可以理解为React.createElement生成的对象类型
        
        `JSX.Element`
        
        JSX.Element是一个ReactElement，道具的泛型类型是任意类型。它存在，因为各种库都可以以自己的方式实现JSX，因此JSX是一个全局命名空间，然后由该库设置，React对其进行如下设置：
        
        ```tsx
        declare global {
          namespace JSX {
            interface Element extends React.ReactElement<any, any> { }
          }
        }
        ```
        
    - render props 使用过程
        1. 提供一个具有逻辑的组件, 该组件接收一个返回结构的函数, 并且在该组件本身的 `render`
            
            中返回这个函数的调用, 
            
            ```tsx
            import React, { Component } from 'react'
            
            // render props
            // jsx的类型是
            // type Props = {
            //   render: (state: State) => React.ReactElement
            // }
            type Props = {
              render: (state: State) => JSX.Element // jsx
              children?: React.ReactNode
            }
            
            type State = {
              x: number
              y: number
            }
            export default class MouseCom extends Component<Props, State> {
              state = {
                x: 0,
                y: 0,
              }
            
              handleMouseMove = (e: MouseEvent) => {
                console.log(e.pageX, e.pageY)
                this.setState({
                  x: e.pageX,
                  y: e.pageY,
                })
              }
              componentDidMount() {
                document.addEventListener('mousemove', this.handleMouseMove)
              }
              // 组件卸载
              componentWillUnmount() {
                document.removeEventListener('mousemove', this.handleMouseMove)
              }
              render() {
                return this.props.render(this.state)
              }
            }
            ```
            
        2. 使用该组件的时候, 提供 render函数和所需的入参, 来实现复用该组件的逻辑
            
            ```tsx
            import React, { Component } from 'react'
            import MouseCom from './components/MouseCom'
            import Image from './components/Image'
            import Position from './components/Position'
            
            export default class Not extends Component {
              render() {
                return (
                  <div>
                    <MouseCom render={(state) => <Image {...state}></Image>}></MouseCom>
                    <MouseCom render={(state) => <Position {...state}></Position>}></MouseCom>
                  </div>
                )
              }
            }
            ```
            
    - render props 的缺点
        
        如果逻辑需要嵌套复用会导致嵌套验证, 不好理解
        
- `高阶组件 HOC` 实现逻辑复用(HOC是react中用于复用组件逻辑的一种高级技巧):
    
    包装模式: 通过包装模式 来增强组件的能力
    
    高阶组件: **是一个函数(**通常以 with开头**)**, 接受一个组件, 返回一个增强后的新组件
    
    高阶组件命名: `withMouse`  `withRouter` 
    
    - 高阶组件的使用:  注意把高阶组件中的props传递给传入的组件
        1. 创建一个包装函数, 函数中返回一个 react 类组件, 该类组件提供逻辑, 但是 `render` 的内容则通过包装函数传入 
            
            ```tsx
            import React from 'react'
            
            export default function withMouse(Com: any) {
              // 内部定义一个类组件
              class Mouse extends React.Component {
                state = {
                  x: 0,
                  y: 0,
                }
                handleMouseMove = (e: MouseEvent) => {
                  console.log(e.pageX, e.pageY)
                  this.setState({
                    x: e.pageX,
                    y: e.pageY,
                  })
                }
                componentDidMount() {
                  document.addEventListener('mousemove', this.handleMouseMove)
                }
                // 组件卸载
                componentWillUnmount() {
                  document.removeEventListener('mousemove', this.handleMouseMove)
                }
                render() {
                  return <Com {...this.state} {...this.props}></Com>
                }
              }
              return Mouse
            }
            
            `组件`
            import React from 'react'
            
            type Props = {
              x: number
              y: number
              left?: number
              top?: number
            }
            export default function Position({ x, y, top = 0, left = 0 }: Props) {
              return (
                <div>
                  Position组件
                  <div>x: {x}</div>
                  <div>y: {y}</div>
                  <div>top: {top}</div>
                  <div>left: {left}</div>
                </div>
              )
            }
            ```
            
        2. 使用时, 将需要包装增强的组件传入该函数中, 可得到一个包装后的组件
            
            ```tsx
            import HPosition from './hoc/Position'
            import withMouse from './hoc/withMouse'
            const PositionWith = withMouse(HPosition)
            
            export default class Not extends Component {
              render() {
                return (
                  <div>
                    {/* HOC */}
                    <PositionWith></PositionWith>
                    <hr />
                  </div>
                )
              }
            }
            ```
            
    - 高阶组件的缺点:
        1. 组件的结构变乱, 变得难维护
        2. 使用繁琐
- `hooks` 实现逻辑复用:
    
    `hooks` 解决的问题: 
    
    组件之间的状态和逻辑复用很麻烦,组件的结构总会变的难以维护,  而 `hooks` 让我们在组件结构不变的情况下实现了代码逻辑复用. 而且使用起来更加简单.
    
    `hooks` 的好处:
    
    1. 带来更好的逻辑复用
    2. 解决了类组件中声明周期将代码逻辑拆分的问题
    3. 解决类组件中 `this` 难以理解的问题 

### 性能优化

- 组件的更新机制
    
    `setState` 调用, 修改状态, 渲染UI
    
    **渲染UI过程**: 父组件重新渲染时, 其所有的子组件会自动重新渲染, 即使是子组建的状态没有改变(虚拟 diff更新)
    
- 性能优化原则: 功能第一, 性能优化第二
- **类组件性能优化方式**
    1. **减轻 `setState`** : 
        1. 只存储和渲染相关的数据. (比如 loading, list等)
        2. 定时器id等和渲染无关的数据不要放置setState中, 直接挂载到 `this` 上
    2. `**shouldComponentUpdate` 生命周期函数**: 在组件更新前执行, 用于判断是否更新
        1. 返回一个布尔值, 默认值为 true, 直接更新组件, 如果设置值为false, 则不更新
        2. 有两个参数, `nextProps` 和 `nextState` , 可通过对比当前 `props` 和 `state` 来决定要不要更新组件
            
            ```tsx
            shouldComponentUpdate(nextProps: any, nextState: any) {
              return nextState.x !== this.state.x || nextState.y !== this.state.y
            }
            ```
            
            > 注意: `shouldComponentUpdate` 是极少使用的钩子, 可能会导致想要的更新没有执行, 最好让react自己判断要不要进行更新
            > 
    3. **纯组件 `React.PureComponent`** 
        
        `PureComponent` 组件和 `Component` 组件功能类型, 
        
        `PureComponent` 在内部自己实现了 `shouldComponentUpdate`  钩子函数, 自动判断 props 和 state 的值是否变化, 最后决定是否重新渲染组件
        
        **什么时候使用纯组件?**
        
        不要所有的组件都使用纯组件, 只有真正在需要性能优化的时候使用. 因为纯组件是需要消耗额外性能进行对比的
        
        **纯组件比较 - 值类型**
        
        纯组件的内部对比是浅层对比, 对于prop或者state是值类型来说, 直接对比两个值即可, 没有问题
        
        **纯组件比较 - 引用类型**
        
        对于引用类型来说, 比较的是引用地址. (这里也是一直说在react中调用 `setState` 时, 要用新值替换原有的值的原因) 
        
        ```jsx
        PureComponent 会在 render 之前对比新 state 和旧 state 的每一个 key，以及新 props 和旧 props 的每一个 key。
        如果所有 key 的值全都一样，就不会 render；如果有任何一个 key 的值不同，就会 render。
        
        // 做性能优化
        class App extends React.PureComponent {    // 只需改这一行便有了 上面的功能
        ```
        
- **函数组件性能优化方式**
    1. `React.memo` (高阶组件, 作用相对于类组件的 `React.PureComponent` 或者`**shouldComponentUpdate**`) 
        
        **依旧是浅层对比**
        
        组件更新过程: 
        
        子组件props变化: 组件代码执行 ⇒ JSX Diff(配合虚拟DOM) ⇒ 重新渲染
        
        子组件props没有变化: 组件代码执行 ⇒ JSX 虚拟DOM对比 ⇒ 不重新渲染
        
        在子组件的props没有变化时, 其实是不需要更新的, 也就是不必要进行 diff对比虚拟DOM, 这个时候可以考虑使用 `React.memo`
        
        ```tsx
        import React from 'react'
        
        function Son() {
          return <div>Som</div>
        }
        
        export default React.memo(Son)
        ```
        
    2. `useCallback`  和 `useMemo`: 解决 `React.memo` 失效的问题
        
        `React.memo` 的问题: 被其包裹的组件会被缓存, 但是每次组件更新都会创建新的props的值(比如事件处理函数等) 这就导致 `React.memo` 在处理对象类型的props会失效. (每次props都是新的对象, `React.memo` 是浅层对比
        
        `useCallback` 配合 `React.memo` 解决 memo 失效问题
        
        `useCallback` 配合其依赖性, 用于记忆某个回调函数是否发生变化, 最终用于判断子组建是否更新
        
        ```tsx
        // f
        import React, { useCallback } from 'react'
        import Son from './Son'
        
        function F() {
          const [count, setCount] = React.useState(0)
          const add = useCallback(
            (num: number) => {
              setCount(count + num)
            },
            [count],
          )
          return (
            <div>
              <Son add={add}></Son>
            </div>
          )
        }
        
        export default React.memo(F)
        
        // Son
        import React from 'react'
        
        type Props = {
          add: (num: number) => void
        }
        
        function Son({ add }: Props) {
          return (
            <div>
              <button onClick={() => add(10)}> +10 </button>
            </div>
          )
        }
        
        export default React.memo(Son)
        
        ```
        
    3. `useMemo` : 
        
        使用和 `useCallback` 一样, 用于缓存回调函数. 
        
        `useMemo` 可以记忆任意类型的数据, `useCallback` 只能记忆函数. 如果记忆函数, 推荐 `useCallback`
        
        `useMemo` 有点类似于vue中的计算属性.
        
        ```tsx
        import React, { useCallback, useMemo } from 'react'
        import Son from './Son'
        
        function F() {
          const [count, setCount] = React.useState(0)
          const add = useCallback(
            (num: number) => {
              setCount(count + num)
            },
            [count],
          )
          // 记忆普通数据
          **const count2 = useMemo(() => {
            return count * 2
          }, [count])
        
          // 记忆函数
          const add2 = useMemo(() => {
            return () => {
              console.log(count2)
            }
          }, [count2])**
          return (
            <div>
              <Son add={add}></Son>
            </div>
          )
        }
        
        export default React.memo(F)
        ```
        

### 虚拟DOM和DIFF算法

- 为什么需要虚拟DOM? 1. 提高渲染性能 2. 跨平台
    1. 首先虚拟DOM就是一个普通的 js 对象, 结构要比真实DOM简单的多, 所以生成虚拟DOM消耗及小.
    2. react会根据JSX结构生成虚拟DOM树, 在根据虚拟DOM树渲染真实DOM树, 
    3. 当数据发生改变, react会生成新的虚拟DOM树, 然后根据diff算法对比前后两次虚拟DOM树的不同, 由虚拟DOM树的不同来更新真实DOM树(最大限度的减少DOM操作)
- `diff` 算法
    
    传统的 `diff算法` , 复杂度的为 **n*3**, 但是 react中 实现的 `diff 算法` 复杂度为 **n** 
    
    react diff 算法是深度优先还是广度优先 ? 深度优先
    
    react中 `diff算法` 的策略:
    
    1. tree diff: 只对比同级, 不跨级进行对比 (如果节点类型发生改变, 则直接销毁整个DOM并且重建, 如果节点类型没有改变, 那么对比其属性, 并且对变化的属性进行更新). 然后对子节点进行递归遍历, 在子节点末尾新增节点时开销较小, 但是在子节点前新增节点时, 开销较大. 就这带来性能问题, 这就是需要唯一的 key 来解决的问题 
    2. key:  当元素携带 key 属性时, 节点对比时, 会将相同 key 的节点进行对比, 如果没有 key 则按顺序对比, 最后, 进行差异化更新, 最大限度的减少消耗. (key 起到唯一标记的作用, 所以 key 不可重复)  
    
    **react diff 的 缺点**
    

### React架构

- **react15**: 提供的 `diff` 算法容易出现丢帧的情况
    
    **浏览器的丢帧:** 浏览器每秒刷新60次, 每一帧所需要的时间约为 `16.7ms`,  而  `GUI渲染线程`和  `JS 线程`是互斥的(js执行和浏览器布局绘制不能同时进行), 在同一时间只能执行js代码或者渲染dom元素, 如果主线程一直被js占用, 那么**渲染引擎**无法在规定时间(浏览器刷新频率 **16.7**ms)内完成工作，使得页面出现**卡顿(掉帧)**，影响用户体验。
    
    **react15架构:**   
    
    **协调器 `Reconciler`** 负责调用render 生成虚拟 DOM, 进行 Diff, 找出变化后的DOM
    
    **渲染器 `Renderer`** 负责接收`Reconciler` 通知, 将变化的组件渲染在当前宿主环境(react-dom/react-native)
    
    **react15架构易出现的缺陷:**
    
    Reconciler 进行 diff 时, 如果节点非常多, 即使是只有一次state变更, react也需要进行复杂的递归更新(占用主线程), 而更新一旦开始, **中途是无法中断的**, 直到遍历完, **才能释放 JS 主线程. 导致页面掉帧卡顿**
    
    **状态更新:**
    
    - 批处理: 多次调用 setState() 会合并为一次更新
    - 原理: 调用 setState 不会立即更新状态, 而是存储到 一个react队列中, 导致 在同步异步操作时, setState 表现不一致
    
    ![Untitled](React%20068a8677f1874d7d8beabb6002f19b86/Untitled.png)
    
- **react16**: 提供 `Fiber` 架构重构 ⇒ `requestIdleCallback API` 但由于兼容性不好，加上该回调函数被调用的频率太低，react实际使用的是一个polyfill(自己实现的api)，而不是requestIdleCallback。
    
    `**Fiber` 架构:** 
    
    `Scheduler`: 调度任务的优先级, 高优先级先进入 Reconciler
    
    `Reconciler`: 找出变化的组件, (使用 `Fiber` 重构)
    
    `Renderer`: 负责将变化的组件渲染到页面上
    
    `**Fiber` 核心**: 组件渲染可中断, 保证浏览器 `GUI` 渲染不丢帧
    
    **如何实现**: 
    
    - 时间切片(大任务拆分成小任务 ⇒ 受限CPU) 基于 **`MessageChannel` API** 实现的
        
        在浏览器每一帧的时间中预留一些时间给JS线程, react利用预留的这部分时间更新组件(diff), 当时间不够用时, react将线程控制权交还给浏览器, 让他有时间渲染UI, react则等待下一帧在继续执行被中断的任务
        
        ```tsx
        我们知道通过 setTimeout，可以向消息队列中添加一个宏任务。当该宏任务被处理时，对应的 callback 会被 js 引擎处理。
        基于次，我们可以通过 eventLoop 来实现时间分片以及重新请求时间片。
        一段 js 程序，如果在规定时间内没有结束，那我们可以主动结束它，然后通过 setTimeout 请求一个新的时间片，在下一个时间片内继续处理上一次没有结束的任务。
        
        // 伪代码
        
        let taskQueue = [...];   // js 程序要处理的任务列表
        let shouldTimeEnd = 5ms;  // 一个时间片定义为 5ms
        
        function processTaskQueue() {
            let beginTime = performance.now();  // 记录开始时间
            while(true) { // 循环处理 taskQueue 中的任务
                let currentTime = performance.now(); // 记录下一个任务开始时的时间
                if (currentTime - beginTime >= shouldTimeEnd) break; // 时间片到期，结束任务处理
                processTask();  // 没有到期，继续处理任务
            }
            if (taskQueue.length) {  // 时间到期，通过 setTimeout 请求下一个时间片继续处理任务
                setTimeout(processTaskQueue, 0); // 在下一个时间片内，继续处理任务
            }
        }
        
        processTaskQueue();
        
        使用 setTimemout 会有一个问题，尽管设置了延时时间为 0ms，但实际上仍然会有大概 4ms 左右的延迟，导致下一个时间片不能尽快拿到. 可以使用 MessageChannel 来替换 setTimeout。使用 MessageChannel 时，只会有大概 1ms 左右的延迟，可以尽快的拿到下一个时间片。
        
        // 伪代码
        
        let taskQueue = [...];   // 任务列表
        let shouldTimeEnd = 5ms;   // 一个时间片定义为 5ms
        let channel = new MessageChannel();  // 创建一个 MessageChannel 实例
        
        function processTaskQueue() {
            let beginTime = performance.now();  // 记录开始时间
            while(true) { // 循环处理 taskQueue 中的任务
                let currentTime = performance.now();  // 记录下一个任务开始时的时间
                if (currentTime - beginTime >= shouldTimeEnd) break;  // 时间片已经到期，结束任务处理
                processTask();  // 时间片没有到期，继续处理任务
            }
            if (taskQueue.length) { // 时间片到期，通过调用 postMessage，请求下一个时间片
                channel.port2.postMessage(null); 
            }
        }
        
        channel.port1.onmessage = processTaskQueue;  // 在下一个时间片内继续处理任务
        processTaskQueue();
        ```
        
    - 任务优先级调度(优先级划分)
        
        浏览器本身的**任务调度**是没有**优先级**概念的，遵循的是 **FIFO** 策略，即先进入**消息队列**里面的任务先处理。但是用户的**交互操作**是有**优先级**的，比如一次点击操作，用户会期望能快速看到结果，优先级较高；切换页面，可以延迟一些，优先级不高。为了可以根据**优先级**进行任务调度，**react** 自身在浏览器 **eventLoop** 的基础上，实现了一套带**优先级**的任务调度 - **workLoop**。
        
- react17: 过度版本, 用来稳定 **`Concurrent Mode` ,** 并且提供新的优先级算法

### react18: **渲染是可中断的**

> **`React 18`** 已经放弃了对 **`ie11`** 的支持
> 

`React 17` 和 `React 18` 的区别就是：从`同步不可中断更新`变成了`异步可中断更新`。

新特性: 

- 新的 `render API`
    
    为了更好的管理**`root节点`**，**`React 18`** 引入了一个新的 **`root API`**，新的 **`root API`**  支持 **`new concurrent r`ender**（并发模式的渲染），它允许你进入**`concurrent mode`**（并发模式）。
    
    如果你坚持在react18中使用react17的render API 也可以, react18兼容旧的render API (忽略警告即可)
    
    ```tsx
    // React 17
    import React from 'react';
    import ReactDOM from 'react-dom';
    import App from './App';
    
    const root = document.getElementById('root')!;
    
    ReactDOM.render(<App />, root);
    
    // React 18
    import React from 'react';
    import ReactDOM from 'react-dom/client';
    import App from './App';
    
    const root = document.getElementById('root')!;
    
    ReactDOM.createRoot(root).render(<App />);
    
    // 卸载组件
    // 同时，在卸载组件时，我们也需要将 unmountComponentAtNode 升级为 root.unmount
    
    // React 17
    ReactDOM.unmountComponentAtNode(root);
    
    // React 18
    root.unmount();
    ```
    
    另外，如果使用了 `typescript` 则需要显示定义 `props` 的 `children` 属性了
    
    ```tsx
    // React 17
    interface MyButtonProps {
      color: string;
    }
    
    const MyButton: React.FC<MyButtonProps> = ({ children }) => {
      // 在 React 17 的 FC 中，默认携带了 children 属性
      return <div>{children}</div>;
    };
    
    export default MyButton;
    
    // React 18
    interface MyButtonProps {
      color: string;
      children?: React.ReactNode;
    }
    
    const MyButton: React.FC<MyButtonProps> = ({ children }) => {
      // 在 React 18 的 FC 中，不存在 children 属性，需要手动申明
      return <div>{children}</div>;
    };
    
    export default MyButton;
    ```
    
    除此之外，**`React 18`** 还从 **`render`** 方法中删除了**`回调函数`**，因为当使用**`Suspense`**时，它通常不会有预期的结果。
    
    在新版本中，如果需要在 **`render`** 方法中使用回调函数，我们可以在组件中通过 **`useEffect`** 实现：
    
    ```tsx
    // React 17
    const root = document.getElementById('root')!;
    ReactDOM.render(<App />, root, () => {
      console.log('渲染完成');
    });
    
    // React 18
    const AppWithCallback: React.FC = () => {
      useEffect(() => {
        console.log('渲染完成');
      }, []);
      return <App />;
    };
    const root = document.getElementById('root')!;
    ReactDOM.createRoot(root).render(<AppWithCallback />)
    ```
    
- `**ConCurrent Mode`  并发模式**
    
    > CM 本身并不是一个功能，而是一个底层设计, 所谓的渲染可中断
    > 
    
    并发模式可帮助应用保持响应，并根据用户的设备性能和网速进行适当的调整，该模式通过使渲染可中断来修复`阻塞渲染`限制。在 `Concurrent` 模式中，`React` 可以同时更新多个状态。
    
    说的太复杂可能有点拗口，总结一句话就是：
    
    `React 17` 和 `React 18` 的区别就是：从`同步不可中断更新`变成了`异步可中断更新`。
    
    **在 `18` 中，是以`是否使用并发特性`作为`是否开启并发更新`的依据**。
    
    并发特性: 
    
    - `useTransition` :
        
        ```tsx
        import React, { useState, useEffect, useTransition } from 'react';
        
        const App: React.FC = () => {
          const [list, setList] = useState<any[]>([]);
          const [isPending, startTransition] = useTransition();
          useEffect(() => {
            **// 使用了并发特性，开启并发更新**
            startTransition(() => {
              setList(new Array(10000).fill(null));
            });
          }, []);
          return (
            <>
              {list.map((_, i) => (
                <div key={i}>{i}</div>
              ))}
            </>
          );
        };
        
        export default App;
        ```
        
    - **`useDeferredValue`**
        
        返回一个延迟响应的值，可以让一个**`state`**  延迟生效，只有当前没有紧急更新时，该值才会变为最新值。**`useDeferredValue`** 和 **`startTransition`**一样，都是标记了一次非紧急更新。
        
        - 相同：`useDeferredValue` 本质上和内部实现与 `useTransition` 一样，都是标记成了`延迟更新`任务。
        - 不同：`useTransition` 是把更新任务变成了延迟更新任务，而 `useDeferredValue` 是产生一个新的值，这个值作为延时状态。（一个用来包装方法，一个用来包装值）
        
        ```tsx
        import React, { useState, useEffect, useDeferredValue } from 'react';
        
        const App: React.FC = () => {
          const [list, setList] = useState<any[]>([]);
          useEffect(() => {
            setList(new Array(10000).fill(null));
          }, []);
          // 使用了并发特性，开启并发更新
          const deferredList = useDeferredValue(list);
          return (
            <>
              {deferredList.map((_, i) => (
                <div key={i}>{i}</div>
              ))}
            </>
          );
        };
        
        export default App;
        ```
        
    - 没有使用并发特性的普通情况
        
        ```tsx
        import React, { useState, useEffect } from 'react';
        
        const App: React.FC = () => {
          const [list, setList] = useState<any[]>([]);
          useEffect(() => {
            setList(new Array(10000).fill(null));
          }, []);
          return (
            <>
              {list.map((_, i) => (
                <div key={i}>{i}</div>
              ))}
            </>
          );
        };
        
        export default App;
        ```
        
    - 结论: 基于 `fiber` 实现的并发
        - 并发更新的意义就是`交替执行`不同的任务，当预留的时间不够用时，`React` 将线程控制权交还给浏览器，等待下一帧时间到来，然后继续被中断的工作
        - `并发模式`是实现`并发更新`的基本前提
        - `时间切片`是实现`并发更新`的具体手段
        - 上面所有的东西都是基于 `fiber` 架构实现的，`fiber`为状态更新提供了可中断的能力
- **`setState`** 自动批处理
    
    [https://www.notion.so/React-9610e7e391874a7e9772e193899906f9#7834679cb81c4b11bf02526cdd1ffcf0](https://www.notion.so/React-9610e7e391874a7e9772e193899906f9)
    
    `React 18` 解决之前版本中, 在setTimeout/原生事件中/不会自动批量处理的破绽
    
    - `react18` 之前, 调用 `setState` 的情况说明
        
        ```tsx
        // 在**React 18 之前**，我们只在 **React 事件处理函数**中进行批处理更新。默认情况下，
        // 在**promise , setTimeout原生事件处理函数**中、或**任何其它事件内** 的更新都不会进行批处理
        // 原因: react无法处理上下文中的this情况
        import React, { useState } from 'react';
        
        // React 18 之前
        const App: React.FC = () => {
          console.log('App组件渲染了！');
          const [count1, setCount1] = useState(0);
          const [count2, setCount2] = useState(0);
          return (
            <button
              onClick={() => {
                setCount1(count => count + 1);
                setCount2(count => count + 1);
                // 在React事件中被批处理 点击一下, 打印一次 `app组件渲染了`
              }}
            >
              {`count1 is ${count1}, count2 is ${count2}`}
            </button>
          );
        };
        
        export default App;
        
        // react18之前
        import React, { useState } from 'react';
        
        // React 18 之前
        const App: React.FC = () => {
          console.log('App组件渲染了！');
          const [count1, setCount1] = useState(0);
          const [count2, setCount2] = useState(0);
          return (
            <div
              onClick={() => {
                setTimeout(() => {
                  setCount1(count => count + 1);
                  setCount2(count => count + 1);
                });
                // 在 setTimeout 中不会进行批处理, 点击一次, 打印两次 `App组件渲染了`
              }}
            >
              <div>count1： {count1}</div>
              <div>count2： {count2}</div>
            </div>
          );
        };
        
        export default App;
        
        ```
        
    - `react18` 任何情况都会自动执行批处理，多次更新始终合并为一次(sync/await 除外)
        
        ```tsx
        import React, { useState } from 'react'
        
        function SetState() {
          console.log('App组件渲染了！')
          const [count1, setCount1] = useState(0)
          const [count2, setCount2] = useState(0)
          return (
            <div
              onClick={async () => {
                await setCount1((count) => count + 1)
                setCount2((count) => count + 1)
              }}
            >
              <div>count1： {count1}</div>
              <div>count2： {count2}</div>
            </div>
          )
        }
        
        export default SetState
        ```
        
    - `flushSync` 批处理是一个**`破坏性改动`**，如果你想退出批量更新，你可以使用 **`flushSync` 但是**函数内部多个 `setState` 仍是批量更新
        
        ```tsx
        const click = () => {
            flushSync(() => {
              console.log(1)
              setCount1(count1 + 1)
            })
            console.log(2)
        
            setCount2(count2 + 1)
          }
        // 两个setCount分开更新, flushSync 内部的setCount更新完成后, 在执行外面的setCout, 组件更新两次
        ```
        
- 删除组件卸载时的警告
    
    ![这个错误表示：**无法对未挂载（已卸载）的组件执行状态更新。这是一个无效操作，并且表明我们的代码中存在内存泄漏。**](React%20068a8677f1874d7d8beabb6002f19b86/Untitled%201.png)
    
    这个错误表示：**无法对未挂载（已卸载）的组件执行状态更新。这是一个无效操作，并且表明我们的代码中存在内存泄漏。**
    
    实际上，这个错误并不多见，在以往的版本中，这个警告被广泛误解，并且有些误导。
    
    这个错误的初衷，原本旨在针对一些特殊场景，譬如 `你在useEffect里面设置了定时器，或者订阅了某个事件，从而在组件内部产生了副作用，而且忘记return一个函数清除副作用，则会发生内存泄漏……` 之类的场景
    
    但是在实际开发中，更多的场景是，`我们在 useEffect 里面发送了一个异步请求，在异步函数还没有被 resolve 或者被 reject 的时候，我们就卸载了组件`。 在这种场景中，警告同样会触发。但是，在这种情况下，组件内部并没有内存泄漏，因为这个异步函数已经被垃圾回收了，此时，**警告具有误导性**。
    
- 组件返回值显示返回undefined不在报错(ts可忽略警告)
    
    在 `React 17` 中，如果你需要返回一个`空组件`，React只允许返回`null`。如果你显式的返回了 `undefined`，控制台则会在运行时抛出一个错误。在 `React 18` 中，不再检查因返回 `undefined` 而导致崩溃。既能返回 `null`，也能返回 `undefined`（但是 `React 18` 的`dts`文件还是会检查，只允许返回 `null`，你可以忽略这个类型错误）。
    
- **Strict Mode (严格模式)**
    
    不再抑制控制台日志：
    
    当你使用`严格模式`时，React 会对每个组件进行`两次渲染`，以便你观察一些意想不到的结果。在 `React 17` 中，取消了`其中一次渲染`的控制台日志，以便让日志更容易阅读。
    
    为了解决社区对这个问题的困惑，在 `React 18` 中，官方取消了这个限制。如果你安装了`React DevTools`，第二次渲染的日志信息将显示为灰色，以柔和的方式显式在控制台。
    
    [https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e7c1a0da9d824e2ba2ef7b9af32fbc91~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp?](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e7c1a0da9d824e2ba2ef7b9af32fbc91~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp?)
    
- **Suspense 不再需要 fallback 来捕获**
- 面向第三方库的 `API`
    
    `useSyncExternalStore`  redux 库
    
     是一个新的api，经历了一次修改，由 `useMutableSource` 改变而来，主要用来解决外部数据撕裂问题。
    
    useSyncExternalStore 能够通过强制同步更新数据让 React 组件在 CM 下安全地有效地读取外接数据源。 在 Concurrent Mode 下，React 一次渲染会分片执行（以 fiber 为单位），中间可能穿插优先级更高的更新。假如在高优先级的更新中改变了公共数据（比如 redux 中的数据），那之前低优先的渲染必须要重新开始执行，否则就会出现前后状态不一致的情况。
    
    `useSyncExternalStore` 一般是三方状态管理库使用，我们在日常业务中不需要关注。因为 `React` 自身的 `useState` 已经原生的解决的并发特性下的 `tear（撕裂）`问题。`useSyncExternalStore` 主要对于框架开发者，比如 `redux`，它在控制状态时可能并非直接使用的 `React` 的 `state`，而是自己在外部维护了一个 `store` 对象，用`发布订阅模式`实现了数据更新，脱离了 `React` 的管理，也就无法依靠 `React` 自动解决撕裂问题。因此 `React` 对外提供了这样一个 API。
    
    目前 `React-Redux 8.0` 已经基于 `useSyncExternalStore` 实现。
    
    **`useInsertionEffect`  css-in-js库**
    
    ```tsx
    const useCSS = rule => {
      useInsertionEffect(() => {
        if (!isInserted.has(rule)) {
          isInserted.add(rule);
          document.head.appendChild(getStyleForRule(rule));
        }
      });
      return rule;
    };
    
    const App: React.FC = () => {
      const className = useCSS(rule);
      return <div className={className} />;
    };
    
    export default App;
    ```
    
- 服务端渲染
    
    `useId`: 
    
    支持同一个组件在客户端和服务端生成相同的唯一的 ID，避免 `hydration` 的不兼容，这解决了在 `React 17` 及 `17` 以下版本中已经存在的问题。因为我们的服务器渲染时提供的 `HTML` 是`无序的`，`useId` 的原理就是每个 `id` 代表该组件在组件树中的层级结构。